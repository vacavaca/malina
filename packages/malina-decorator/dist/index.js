"use strict";Object.defineProperty(exports,"__esModule",{value:true});var t=require("malina");var e=require("malina-util");function n(t,e,n,r,s,o,i){try{var a=t[o](i);var l=a.value}catch(t){n(t);return}if(a.done){e(l)}else{Promise.resolve(l).then(r,s)}}function r(t){return function(){var e=this,r=arguments;return new Promise(function(s,o){var i=t.apply(e,r);function a(t){n(i,s,o,a,l,"next",t)}function l(t){n(i,s,o,a,l,"throw",t)}a(undefined)})}}function s(t,e,n){if(e in t){Object.defineProperty(t,e,{value:n,enumerable:true,configurable:true,writable:true})}else{t[e]=n}return t}function o(t){for(var e=1;e<arguments.length;e++){var n=arguments[e]!=null?arguments[e]:{};var r=Object.keys(n);if(typeof Object.getOwnPropertySymbols==="function"){r=r.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))}r.forEach(function(e){s(t,e,n[e])})}return t}const i=t=>e=>{if(t instanceof Function)return t(e)||{};else return t||{}};const a=e=>t.decorator(n=>{const r=i(n.state);const s=i(e);const a=t=>{const e=r(t);const n=s(t);return o({},e,n)};return t.view(n.template,a,n.actions,n.hooks)});const l=e=>t.decorator(n=>{const r=i(n.actions);const s=i(e);const a=t=>o({},r(t),s(t));return t.view(n.template,n.state,a,n.hooks)});const c=e=>t.decorator(n=>{const r=i(n.hooks);const s=i(e);const a=t=>{const e=r(t);const n=s(t);const i=o({},e);for(const t in n){i[t]=((r,s,o)=>{const i=()=>{if(e[t]!=null)e[t](r,s,o)};n[t](i)(r,s,o)})}return i};return t.view(n.template,n.state,n.actions,a)});const u=e=>t.decorator(n=>t.view(e(n.template),n.state,n.actions,n.hooks));const f=e=>t.decorator(n=>(r,s,o)=>t.h(n,e(r),o));const d=()=>t.warn(`Too many views are decorated with the same decorator, you are probably leaking view declarations i.e. declaring new views while running or rendering!\n\nKeep in mind that due to the declarative style of this library it's recommended to declare all your views statically, in the top-level scope of your modules.`);const h=(e,n=1e4)=>{const r=new Map;const s=n;return t.decorator(n=>{if(r.has(n.template))return r.get(n.template);else{let o=e(n);if(r.size<s)r.set(n.template,o);if(t.isDevelopment&&r.size>=s*.9)d();return o}})};class p{constructor(){this.listenerCounter=0;this.listeners={}}subscribe(t){const e=++this.listenerCounter;this.listeners[e]=t;return()=>delete this.listeners[e]}notify(...t){for(const e in this.listeners)this.listeners[e](...t)}}const m=Symbol("context");class v{constructor(t={}){this.value=t;this.emitter=new p}subscribe(t){return this.emitter.subscribe(t)}update(t){const n=o({},this.value,t);if(e.shallowEqual(this.value,n))return;this.value=n;this.emitter.notify(this.value)}get(){return this.value}}const y=h(u(t=>(e,n,r)=>{const s=e[m];const o=t(e,n,r);if(s!=null)return w(s)(o);else return o}));const w=e=>n=>{if(!Array.isArray(n)){if(t.isViewNode(n)){const r=o({},n.attrs!=null?n.attrs:{},{[m]:e});return t.h(y(n.tag),r,n.children)}else if(t.isElementNode(n))return t.h(n.tag,n.attrs,n.children.map(w(e)));else return n}else return n.map(w(e))};const b=t=>t;const g=(t=b)=>{const n=(e,n)=>{const r=t(e,n);if(typeof r!=="object")throw new Error("Context must be an object derived from view's state and actions");return r};return e.compose(c({create:t=>(e,r,s)=>{t();if(!(m in r)){const t=new v(n(r,s));r[m]=t}else{const t=r[m];t.update(n(r,s))}},update:t=>(e,r,s)=>{t();const o=r[m];o.update(n(r,s))}}),y)};const x=Symbol("update");const S=Symbol("subscription");const j=t=>({context:t});const k=(t=j)=>e.compose(c({create:e=>(n,r,s)=>{let o=r[m];if(o!=null)Object.assign(r,t(o.value));e();if(o==null)o=r[m];if(o!=null){r[S]=o.subscribe(s[x]);Object.assign(r,t(o.value))}},destroy:t=>(e,n,r)=>{if(S in n)n[S]();t()}}),l({[x]:e=>()=>o({},t(e))}));const E=(e,n)=>r=>{if(t.isElementNode(r)){if(r.attrs!=null&&n in r.attrs){const s=(r.attrs[n]||"").split(" ").filter(t=>t.length>0);const i=(r.attrs.class||"").split(" ").filter(t=>t.length>0);const a=s.map(t=>e[t]).filter(t=>t!=null).concat(i).join(" ");const l=o({},r.attrs);delete l[n];if(a.length>0)l.class=a;return t.h(r.tag,l,r.children.map(E(e,n)))}else return t.h(r.tag,r.attrs,r.children.map(E(e,n)))}else return r};const N=(t,e="styleName")=>u(n=>(r,s,o)=>{const i=n(r,s,o);return E(t,e)(i)});const O=Symbol("ids");const A=(n,r)=>s=>{if(r==null)return s;if(Array.isArray(s))return s.map(A(n,r.ids));else if(t.isElementNode(s)){let i=s.attrs;if("id"in s.attrs){const a=s.attrs["id"];i=o({},s.attrs);if(a in r.ids)i["id"]=r.ids[a];else{let s;if(t.isDevelopment){let t=++r.id;s=`${t}`;while(s.length<n)s=`0${s}`}else s=e.genRandomId(n);const o=`${a}_${s}`;r.ids[a]=o;i["id"]=o}}return t.h(s.tag,i,s.children.map(A(n,r)))}else if(t.isViewNode(s)){let e=o({},s.attrs);e[O]=r;return t.h(s.tag,e,s.children)}else return s};const P=(t=4)=>e.compose(k(t=>O in t?{[O]:t[O]}:{}),g(t=>{if(!(O in t))return{[O]:{ids:{},id:0}};else return{}}),u(e=>(n,r,s)=>A(t,n[O])(e(n,r,s))));const q=(t,e)=>{let n=t;var r=true;var s=false;var o=undefined;try{for(var i=e[Symbol.iterator](),a;!(r=(a=i.next()).done);r=true){const t=a.value;if(n==null)break;n=n.childNodes[t]||null}}catch(t){s=true;o=t}finally{try{if(!r&&i.return!=null){i.return()}}finally{if(s){throw o}}}return n};const C=Symbol("refs");const V=t=>t.join(".");const $=new Set;const D=1e4;const F=e=>t.warn(`Incorrect use of refs:\n\n${e}\n\nViews can only handle its own refs. When a ref passed to a child-node inside another view-node it will be ignored`);const I=(e,n,r=null)=>{const s=t.isElementNode(n);const o=t.isViewNode(n);if(s&&e in n.attrs){if(r!=null&&$.size<D)$.add(r.tag.id);F(r||n);return true}else if(s||o&&!$.has(n.tag.id)){let t=false;var i=true;var a=false;var l=undefined;try{for(var c=n.children[Symbol.iterator](),u;!(i=(u=c.next()).done);i=true){const s=u.value;t=I(e,s,o?n:r);if(t)break}}catch(t){a=true;l=t}finally{try{if(!i&&c.return!=null){c.return()}}finally{if(a){throw l}}}return t}else return false};const M=(t,e,n,r)=>e.children.map((e,s)=>{const o=n.concat([s]);return z(t,e,o,r).node});const z=(n,r,s,o)=>{const i=t.isElementNode(r);if(i&&n in r.attrs){const i=r.attrs[n];if(!(i instanceof Function))throw new Error("Ref consumer must be a function");o.set(V(s),{path:s,consumer:i});const a=M(n,r,s,o);const l=t.h(r.tag,e.omit([n],r.attrs),a);return{refs:o,node:l}}else if(i){const e=M(n,r,s,o);const i=t.h(r.tag,r.attrs,e);return{refs:o,node:i}}else if(t.isDevelopment&&t.isViewNode(r)&&!$.has(r.tag.id))I(n,r,r);return{refs:o,node:r}};const R=(t,e)=>{const n=new Map;if(Array.isArray(e)){const r=[];for(const s in e){const o=[s];r.push(z(t,e,o,n).node)}return{refs:n,node:r}}else return z(t,e,[],n)};const _=(t,{path:e,consumer:n})=>{const r=q(t,e);if(r==null)throw new Error("Internal error: element not found by ref");n(r)};const T=(t,e,n)=>{var r=true;var s=false;var o=undefined;try{for(var i=n.keys()[Symbol.iterator](),a;!(r=(a=i.next()).done);r=true){const r=a.value;if(e==null||!e.has(r))_(t,n.get(r));else{const s=e.get(r);const o=n.get(r);if(s.consumer!==o.consumer)_(t,o)}}}catch(t){s=true;o=t}finally{try{if(!r&&i.return!=null){i.return()}}finally{if(s){throw o}}}};const H=t=>{var e=true;var n=false;var r=undefined;try{for(var s=t.values()[Symbol.iterator](),o;!(e=(o=s.next()).done);e=true){const t=o.value.consumer;t(null)}}catch(t){n=true;r=t}finally{try{if(!e&&s.return!=null){s.return()}}finally{if(n){throw r}}}};const K=(t="ref")=>e.compose(u(e=>(n,r,s)=>{const o=e(n,r,s);const i=R(t,o),a=i.refs,l=i.node;n[C].next=a;return l}),c({create:t=>(e,n)=>{t();n[C]={prev:null,next:null}},mount:t=>(e,n)=>{T(e,n[C].prev,n[C].next);n[C].prev=n[C].next;t()},update:t=>(e,n)=>{T(e,n[C].prev,n[C].next);n[C].prev=n[C].next;t()},unmount:t=>(e,n)=>{H(n[C].next);t()}}));const U={};U.update=(t=>(function(){var n=r(function*({store:n}){let r=o({},n);let s=t;if(t instanceof Function)s=t(r);if(s instanceof Promise)s=yield s;if(s!=null)r=o({},r,s);if(!e.shallowEqual(n,r))return{store:r}});return function(t){return n.apply(this,arguments)}})());const W=Symbol("store");const B=g((t,e)=>({[W]:{state:t.store,update:e.update}}));const G=e=>B(t.view((t,e,n)=>n,{store:e},U));const J=e=>t.decorator(n=>{const r=G(e);return u(n=>(s,o,i)=>t.h(r,{store:e},n(s,o,i)))(n)});const L=(...t)=>({});const Q=(t=L,e=L)=>k(n=>{if(W in n){const r=n[W];return o({},t(r.state),e(r.update))}else return{}});const X=t=>n=>{const r={};var s=true;var o=false;var i=undefined;try{for(var a=e.keys(t)[Symbol.iterator](),l;!(s=(l=a.next()).done);s=true){const e=l.value;const s=t[e];if(s instanceof Function)r[e]=((...t)=>n(s(...t)));else r[e]=X(s)}}catch(t){o=true;i=t}finally{try{if(!s&&a.return!=null){a.return()}}finally{if(o){throw i}}}return r};exports.withState=a;exports.withActions=l;exports.withHooks=c;exports.withTemplate=u;exports.mapState=f;exports.withContext=g;exports.getContext=k;exports.cssModules=N;exports.withUniqIds=P;exports.withRefs=K;exports.withStore=J;exports.connect=Q;exports.bindActions=X;
