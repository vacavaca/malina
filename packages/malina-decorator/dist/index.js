"use strict";Object.defineProperty(exports,"__esModule",{value:true});var t=require("malina");var e=require("malina-util");function n(t,e,n,r,s,o,i){try{var a=t[o](i);var l=a.value}catch(t){n(t);return}if(a.done){e(l)}else{Promise.resolve(l).then(r,s)}}function r(t){return function(){var e=this,r=arguments;return new Promise(function(s,o){var i=t.apply(e,r);function a(t){n(i,s,o,a,l,"next",t)}function l(t){n(i,s,o,a,l,"throw",t)}a(undefined)})}}function s(t,e,n){if(e in t){Object.defineProperty(t,e,{value:n,enumerable:true,configurable:true,writable:true})}else{t[e]=n}return t}function o(t){for(var e=1;e<arguments.length;e++){var n=arguments[e]!=null?arguments[e]:{};var r=Object.keys(n);if(typeof Object.getOwnPropertySymbols==="function"){r=r.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))}r.forEach(function(e){s(t,e,n[e])})}return t}const i=t=>e=>{if(t instanceof Function)return t(e)||{};else return t||{}};const a=(...e)=>t.decorator(n=>t.view(n.template,t=>{for(var r=0;r<e.length;r++){const n=e[r];n(t)}if(n.behavior instanceof Function)n.behavior(t)},n.actions));const l=t=>a(e=>{e.state=o({},i(t)(e.state),e.state)});const c=e=>t.decorator(n=>t.view(n.template,n.behavior,o({},n.actions||{},e||{})));const u=t=>a(e=>{if("create"in t)t.create(e);if("mount"in t)e.onMount(t.mount);if("update"in t)e.onUpdate(t.update);if("unmount"in t)e.onUnmount(t.unmount);if("destroy"in t)e.onDestroy(t.destroy)});const f=e=>t.decorator(n=>t.view(t=>{const r=()=>{return n.template(t)};return e(r)(t)},n.behavior,n.actions));const d=()=>t.warn(`Too many views are decorated with the same decorator, you are probably leaking view declarations i.e. declaring new views while running or rendering!\n\nKeep in mind that due to the declarative style of this library it's recommended to declare all your views statically, in the top-level scope of your modules.`);const h=(e,n=false,r=1e4)=>{const s=new Map;const o=n?r*2:r;return t.decorator(r=>{const i=r.id;if(s.has(i))return s.get(i);else{let a=e(r);if(s.size<o){s.set(i,a);if(n)s.set(a.id,a)}if(t.isDevelopment&&s.size>=o*.9)d();return a}})};class m{constructor(){this.listenerCounter=0;this.listeners={}}subscribe(t){const e=++this.listenerCounter;this.listeners[e]=t;return()=>delete this.listeners[e]}notify(...t){for(const e in this.listeners)this.listeners[e](...t)}}const p=Symbol.for("__malina_context");class v{constructor(t={}){this.value=t;this.emitter=new m}subscribe(t){return this.emitter.subscribe(t)}update(t,n=false){const r=o({},this.value,t);if(e.shallowEqual(this.value,r))return;this.value=r;if(!n)this.emitter.notify(this.value)}get(){return this.value}}const y=h(f(t=>({state:e})=>{const n=e[p];const r=t();if(n!=null)return w(n)(r);else return r}),true);const w=e=>n=>{if(!Array.isArray(n)){if(t.isViewNode(n)){const r=o({[p]:e},n.attrs!=null?n.attrs:{});return t.h(y(n.tag),r,n.children.map(w(e)))}else if(t.isElementNode(n))return t.h(n.tag,n.attrs,n.children.map(w(e)));else if(n instanceof Function)return(...t)=>w(e)(n(...t));else return n}else return n.map(w(e))};const b=t=>t;const g=(t=b)=>{const n=e=>{const n=t(e);const r=typeof n;if(r!=="object")throw new Error(`Context must be an object, got ${r}`);return n};return e.compose(y,u({create:t=>{if(!(p in t.state)){const e=new v(n(t));t.state[p]=e}else{const e=t.state[p];e.update(n(t))}},update:t=>{const e=t.state[p];e.update(n(t))}}))};const x=Symbol.for("__malina_context_subscription");const _=t=>({context:t});const C=(t=_)=>e.compose(u({create:e=>{let n=e.state[p];if(n!=null){e.state=o({},e.state,t(n.value)||{});e.state[x]=n.subscribe(n=>{e.update(o({},t(n)))})}},destroy:({state:t})=>{if(x in t)t[x]()}}));const S=Symbol.for("__malina_styles");const E=Symbol.for("__malina_styles_update");const A=(t,e)=>o({},e||{},t||{});const N=(t,e)=>{if(e!=null)return e;else return t};const O=(e,n)=>r=>{if(t.isElementNode(r)){if(r.attrs!=null&&n in r.attrs){const s=(r.attrs[n]||"").split(" ").filter(t=>t.length>0);const i=(r.attrs.class||"").split(" ").filter(t=>t.length>0);const a=s.map(t=>e[t]).filter(t=>t!=null).concat(i).join(" ");const l=o({},r.attrs);delete l[n];if(a.length>0)l.class=a;return t.h(r.tag,l,r.children.map(O(e,n)))}else return t.h(r.tag,r.attrs,r.children.map(O(e,n)))}else if(t.isViewNode(r)){const s=o({},r.attrs||null,{[E]:{styles:e,styleAttribute:n}});return t.h(r.tag,s,r.children.map(O(e,n)))}else return r};const k=h(e.compose(f(t=>({state:e})=>{const n=e[S]||{},r=n.styles,s=n.styleAttribute;const o=e[E]||{},i=o.styles,a=o.styleAttribute;const l=A(r,i);const c=N(s,a);const u=t();return O(l,c)(u)})),true);const R=(t,n="styleName")=>e.compose(k,u({create:({state:e})=>{if(S in e)e[S]={styles:o({},e[S].styles,t),styleAttribute:n};else e[S]={styles:o({},t),styleAttribute:n}}}));const j=Symbol.for("__malina_ids");const M=(n,r,s)=>i=>{if(s==null)return i;if(Array.isArray(i))return i.map(M(n,r,s.ids));else if(t.isElementNode(i)){let a=i.attrs;if(r in i.attrs){const t=i.attrs[r];a=o({},i.attrs,{id:t});delete a[r]}else if("id"in i.attrs){const r=i.attrs["id"];a=o({},i.attrs);if(r in s.ids)a["id"]=s.ids[r];else{let o;if(t.isDevelopment){let t=++s.id;o=`${t}`;while(o.length<n)o=`0${o}`}else o=e.genRandomId(n);const i=`${r}_${o}`;s.ids[r]=i;a["id"]=i}}return t.h(i.tag,a,i.children.map(M(n,r,s)))}else return i};const F=(t=4,n="realId")=>e.compose(C(t=>j in t?{[j]:t[j]}:{}),g(({state:t})=>{if(!(j in t)){const e={ids:{},id:0};t[j]=e;return{[j]:e}}else return{}}),f(e=>r=>M(t,n,r.state[j])(e())));const P=(t,e)=>{let n=t;var r=true;var s=false;var o=undefined;try{for(var i=e[Symbol.iterator](),a;!(r=(a=i.next()).done);r=true){const t=a.value;if(n==null)break;n=n.childNodes[t]||null}}catch(t){s=true;o=t}finally{try{if(!r&&i.return!=null){i.return()}}finally{if(s){throw o}}}return n};const $=Symbol.for("__malina_refs");const q=t=>t.join(".");const D=new Set;const I=1e4;const U=e=>t.warn(`Incorrect use of refs:\n\n${e}\n\nViews can only handle its own refs. When a ref passed to a child-node inside another view-node it will be ignored`);const V=(e,n,r=null)=>{const s=t.isElementNode(n);const o=t.isViewNode(n);if(s&&e in n.attrs){if(r!=null&&D.size<I)D.add(r.tag.id);U(r||n);return true}else if(s||o&&!D.has(n.tag.id)){let t=false;var i=true;var a=false;var l=undefined;try{for(var c=n.children[Symbol.iterator](),u;!(i=(u=c.next()).done);i=true){const s=u.value;t=V(e,s,o?n:r);if(t)break}}catch(t){a=true;l=t}finally{try{if(!i&&c.return!=null){c.return()}}finally{if(a){throw l}}}return t}else return false};const L=(t,e,n,r)=>e.children.map((e,s)=>{const o=n.concat([s]);return z(t,e,o,r).node});const z=(n,r,s,o)=>{const i=t.isElementNode(r);if(i&&n in r.attrs){const i=r.attrs[n];if(!(i instanceof Function)&&typeof i!=="string")throw new Error("Ref consumer must be a function or a string");o.set(q(s),{path:s,consumer:i});const a=L(n,r,s,o);const l=t.h(r.tag,e.omit([n],r.attrs),a);return{refs:o,node:l}}else if(i){const e=L(n,r,s,o);const i=t.h(r.tag,r.attrs,e);return{refs:o,node:i}}else if(t.isDevelopment&&t.isViewNode(r)&&!D.has(r.tag.id))V(n,r,r);return{refs:o,node:r}};const T=(t,e)=>{const n=new Map;if(Array.isArray(e)){const r=[];for(const s in e){const o=[s];r.push(z(t,e,o,n).node)}return{refs:n,node:r}}else return z(t,e,[],n)};const B=(t,{path:e,consumer:n})=>{const r=P(t.element,e);if(r==null)throw new Error("Internal error: element not found by ref");if(n instanceof Function)n(r);else t.state[n]=r};const G=(t,e,n)=>{var r=true;var s=false;var o=undefined;try{for(var i=n.keys()[Symbol.iterator](),a;!(r=(a=i.next()).done);r=true){const r=a.value;if(e==null||!e.has(r))B(t,n.get(r));else{const s=e.get(r);const o=n.get(r);if(s.consumer!==o.consumer)B(t,o)}}}catch(t){s=true;o=t}finally{try{if(!r&&i.return!=null){i.return()}}finally{if(s){throw o}}}};const H=(t,e)=>{var n=true;var r=false;var s=undefined;try{for(var o=e.values()[Symbol.iterator](),i;!(n=(i=o.next()).done);n=true){const e=i.value.consumer;if(e instanceof Function)e(null);else t.state[e]=null}}catch(t){r=true;s=t}finally{try{if(!n&&o.return!=null){o.return()}}finally{if(r){throw s}}}};const K=(t="ref")=>e.compose(f(e=>n=>{const r=e();const s=T(t,r),o=s.refs,i=s.node;n.state[$].next=o;return i}),u({create:t=>{t.state[$]={prev:null,next:null}},mount:t=>{G(t,t.state[$].prev,t.state[$].next);t.state[$].prev=t.state[$].next},update:t=>{G(t,t.state[$].prev,t.state[$].next);t.state[$].prev=t.state[$].next},unmount:t=>{H(t,t.state[$].next);t.state[$].prev=null}}));const W={};W.finishUpdate=(t=>({state:n})=>{const r=o({},n.store,t);if(!e.shallowEqual(n.store,r))return{store:r}});W.update=(t=>(function(){var e=r(function*({state:e,actions:n}){let r=o({},e.store);let s=t;if(t instanceof Function)s=t(r);if(s instanceof Promise)s=yield s;if(s!=null)yield n.finishUpdate(s)});return function(t){return e.apply(this,arguments)}})());const J=t=>(function(){var e=r(function*(...e){const n=yield t(...e);return n.store});return function(){return e.apply(this,arguments)}})();const Q=Symbol.for("__malina_store");const X=e.compose(g(({state:t,actions:e})=>({[Q]:{state:t.store,update:J(e.update)}})));const Y=t.view(({state:e,children:n})=>t.h(e.view,e.passed,n)).decorate(l({store:null}),c(W),X);const Z=e=>t.decorator(n=>({state:r,children:s})=>t.h(Y,{store:e,passed:r,view:n},s));const tt=(...t)=>({});const et=(t=tt,e=tt)=>C(n=>{if(Q in n){const r=n[Q];const s=t!=null?t:tt;const i=e!=null?e:tt;return o({},s(r.state),i(r.update))}else return{}});const nt=t=>n=>{const r={};var s=true;var o=false;var i=undefined;try{for(var a=e.keys(t)[Symbol.iterator](),l;!(s=(l=a.next()).done);s=true){const e=l.value;const s=t[e];if(s instanceof Function)r[e]=((...t)=>n(s(...t)));else r[e]=nt(s)(n)}}catch(t){o=true;i=t}finally{try{if(!s&&a.return!=null){a.return()}}finally{if(o){throw i}}}return r};const rt=t=>t.split("-").length>=2;const st=t=>{if(!rt(t))throw new Error(`"${t}" is not valid custom element name`)};const ot=(e,n,r,{shadow:s="open",observe:o=[]})=>(class extends e.HTMLElement{constructor(...t){const n=super(...t);this.view=null;this.childObserver=new e.MutationObserver(this.handleChildMutations.bind(this));this.expectedRemove=[];this.waitingChildren=true;return n}static get observedAttributes(){return o||[]}connectedCallback(){if(this.view==null){const c=this.attachShadow({mode:s});const u={};var r=true;var o=false;var i=undefined;try{for(var a=this.attributes[Symbol.iterator](),l;!(r=(l=a.next()).done);r=true){const t=l.value;u[t.name]=t.value}}catch(t){o=true;i=t}finally{try{if(!r&&a.return!=null){a.return()}}finally{if(o){throw i}}}const f=Array.from(this.childNodes);this.view=t.instantiate(e.document,t.h(n,u,f));const d=this.view.render();c.appendChild(d.content)}this.view.attach(this.shadowRoot);this.childObserver.observe(this,{childList:true})}disconnectedCallback(){this.childObserver.disconnect();this.view.unmount()}attributeChangedCallback(t,e,n){if(this.view!=null){this.view.update({[t]:n})}}destroy(){this.view.destroy()}handleChildMutations(t){var e=true;var n=false;var r=undefined;try{for(var s=t[Symbol.iterator](),o;!(e=(o=s.next()).done);e=true){const t=o.value;if(t.type==="childList"){this.updateChildren(t);break}}}catch(t){n=true;r=t}finally{try{if(!e&&s.return!=null){s.return()}}finally{if(n){throw r}}}}updateChildren(t){if(this.waitingChildren){this.waitingChildren=false;const t=Array.from(this.childNodes);this.expectedRemove=t;this.view.update(null,t)}else{const e=this.expectedRemove.length;if(e!==t.removedNodes.length){this.waitingChildren=true;this.updateChildren(t);return}for(let n=0;n<e;n++){const e=this.expectedRemove[n];const r=t.removedNodes[n];if(e!==r){this.waitingChildren=true;this.updateChildren(t);return}}this.waitingChildren=true;this.expectedRemove=null}}});const it=f(t=>n=>{const r=t();if(r.tag!=="template")throw new Error("Root element of a web-component must be a 'template' element");if(e.keys(r.attrs).length>0)throw new Error("Root element of a web-component must not have any attributes");return r});const at=(e,n,r={})=>{st(n);return t.decorator(t=>{if("customElements"in e){const s=ot(e,it(t),n,r);e.customElements.define(n,s);return s}return null})};const lt=()=>{const e=t.getGlobal();if(!("window"in e))throw new Error('"window" not found in global scope');return e.window};const ct=(...t)=>{if(t.length===1){const e=lt();return at(e,t[0])}else if(t.length===2){if(typeof t[0]==="string"){const e=lt();return at(e,t[0],t[1])}else return at(t[0],t[1])}else return at(t[0],t[1],t[2])};exports.withBehavior=a;exports.withState=l;exports.withActions=c;exports.withLifecycle=u;exports.withTemplate=f;exports.withContext=g;exports.getContext=C;exports.cssModules=R;exports.withUniqIds=F;exports.withRefs=K;exports.withStore=Z;exports.connect=et;exports.bindActions=nt;exports.webComponent=ct;
