"use strict";Object.defineProperty(exports,"__esModule",{value:true});var t=require("malina");var e=require("malina-util");function n(t,e,n,r,s,o,i){try{var a=t[o](i);var l=a.value}catch(t){n(t);return}if(a.done){e(l)}else{Promise.resolve(l).then(r,s)}}function r(t){return function(){var e=this,r=arguments;return new Promise(function(s,o){var i=t.apply(e,r);function a(t){n(i,s,o,a,l,"next",t)}function l(t){n(i,s,o,a,l,"throw",t)}a(undefined)})}}function s(t,e,n){if(e in t){Object.defineProperty(t,e,{value:n,enumerable:true,configurable:true,writable:true})}else{t[e]=n}return t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);if(e)r=r.filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable});n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=arguments[e]!=null?arguments[e]:{};if(e%2){o(n,true).forEach(function(e){s(t,e,n[e])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(t,Object.getOwnPropertyDescriptors(n))}else{o(n).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))})}}return t}const a=t=>t;const l=t=>e=>{if(t instanceof Function)return t(e)||{};else return t||{}};const c=(...e)=>t.decorator(n=>new t.Declaration(n.template,t=>{if(n.behavior instanceof Function)n.behavior(t);for(var r=0,s=e;r<s.length;r++){const e=s[r];e(t)}},n.actions));const u=t=>c(e=>{e.state=i({},l(t)(e.state),{},e.state)});const f=e=>t.decorator(n=>new t.Declaration(n.template,n.behavior,i({},n.actions||{},{},e||{})));const d=t=>c(e=>{if("create"in t)t.create(e);if("mount"in t)e.onMount(t.mount);if("update"in t)e.onUpdate(t.update);if("unmount"in t)e.onUnmount(t.unmount);if("destroy"in t)e.onDestroy(t.destroy)});const h=e=>t.decorator(n=>new t.Declaration(e,n.behavior,n.actions));const p=e=>t.decorator(n=>new t.Declaration(t=>{const r=()=>{return n.template(t)};return e(r)(t)},n.behavior,n.actions));const m=(e=a)=>t.decorator(n=>t.template(({state:r,children:s})=>t.h(n,e(r),s)));const v=(t={})=>m(n=>{const r={};var s=true;var o=false;var i=undefined;try{for(var a=e.keys(t)[Symbol.iterator](),l;!(s=(l=a.next()).done);s=true){const e=l.value;if(e in n)r[t[e]]=n[e]}}catch(t){o=true;i=t}finally{try{if(!s&&a.return!=null){a.return()}}finally{if(o){throw i}}}return r});const y=()=>t.warn(`Too many views are decorated with the same decorator, you are probably leaking view declarations i.e. declaring new views while running or rendering!\n\nKeep in mind that due to the declarative style of this library it's recommended to declare all your views statically, in the top-level scope of your modules.`);const w=(e,n=false,r=1e4)=>{const s=new Map;const o=n?r*2:r;return t.decorator(r=>{const i=r.id;if(s.has(i))return s.get(i);else{let a=e(r);if(s.size<o){s.set(i,a);if(n)s.set(a.id,a)}if(t.isDevelopment&&s.size>=o*.9)y();return a}})};class b{constructor(){this.listenerCounter=0;this.listeners={}}subscribe(t){const e=++this.listenerCounter;this.listeners[e]=t;return()=>delete this.listeners[e]}notify(...t){for(const e in this.listeners)this.listeners[e](...t)}}const g=Symbol.for("__malina_context.context");class x{constructor(t={}){this.value=t;this.emitter=new b}subscribe(t){return this.emitter.subscribe(t)}update(t,n=false){const r=i({},this.value,{},t);if(e.shallowEqual(this.value,r))return;this.value=r;if(!n)this.emitter.notify(this.value)}get(){return this.value}}const _=w(p(t=>({state:e})=>{const n=e[g];const r=t();if(n!=null)return S(n)(r);else return r}),true);const S=e=>n=>{if(!Array.isArray(n)){if(t.isViewNode(n)){const r=i({[g]:e},n.attrs!=null?n.attrs:{});return t.h(_(n.tag),r,n.children.map(S(e)))}else if(t.isElementNode(n))return t.h(n.tag,n.attrs,n.children.map(S(e)));else if(n instanceof Function)return(...t)=>S(e)(n(...t));else return n}else return n.map(S(e))};const C=t=>t;const O=(t=C)=>{const n=e=>{const n=t instanceof Function?t(e):t;const r=typeof n;if(r!=="object")throw new Error(`Context must be an object, got ${r}`);return n};return e.compose(_,d({create:t=>{if(!(g in t.state)){const e=new x(n(t));t.state[g]=e}else{const e=t.state[g];e.update(n(t))}},update:t=>{const e=t.state[g];e.update(n(t))}}))};const E=Symbol.for("__malina_context_subscription");const j=t=>({context:t});const N=(t=j)=>e.compose(d({create:e=>{let n=e.state[g];if(n!=null){e.state=i({},e.state,{},t(n.value)||{});e.state[E]=n.subscribe(n=>{e.update(i({},t(n)))})}},update:e=>{let n=e.state[g];if(n!=null)e.state=i({},e.state,{},t(n.value)||{})},destroy:({state:t})=>{if(E in t)t[E]()}}));const k=Symbol.for("__malina_styles");const P=Symbol.for("__malina_styles_attribute");const D=Symbol.for("__malina_styles_update");const F=Symbol.for("__malina_styles_update_attribute");const A=(t,n)=>{if(n==null||e.keys(n).length===0)return t||{};else if(t==null||e.keys(t).length===0)return n||{};else return i({},n||{},{},t||{})};const R=(t,e)=>{if(e!=null)return e;else return t};const M=(e,n)=>r=>{if(t.isElementNode(r)){if(r.attrs!=null&&n in r.attrs){const s=(r.attrs[n]||"").split(" ").filter(t=>t.length>0);const o=(r.attrs.class||"").split(" ").filter(t=>t.length>0);const a=s.map(t=>e[t]).filter(t=>t!=null).concat(o).join(" ");const l=i({},r.attrs);delete l[n];if(a.length>0)l.class=a;return t.h(r.tag,l,r.children.map(M(e,n)))}else return t.h(r.tag,r.attrs,r.children.map(M(e,n)))}else if(t.isViewNode(r)){const s=i({},r.attrs||null,{[D]:e,[F]:n});return t.h(r.tag,s,r.children.map(M(e,n)))}else return r};const $=w(e.compose(p(t=>({state:e})=>{const n=e||{},r=n[k],s=n[P];const o=e||{},i=o[D],a=o[F];const l=A(r,i);const c=R(s,a);const u=t();return M(l,c)(u)})),true);const q=(t,n="styleName")=>e.compose($,d({create:({state:e})=>{e[k]=A(e[k],t);e[P]=R(e[P],n)}}));const U=Symbol.for("__malina_ids");const V=Symbol.for("__malina-decorator.id.random");const I=t.getGlobal();let L;if(I!=null&&V in I)L=I[V];else{L=new e.Random("malina-decorator.id-seed");if(I!=null)I[V]=L}const T=(e,n,r)=>s=>{if(r==null)return s;if(Array.isArray(s))return s.map(T(e,n,r.ids));else if(t.isElementNode(s)){let l=s.attrs;const c=`${n}Id`;const u=`${n}HtmlFor`;const f=[];if(c in s.attrs){const t=s.attrs[c];l=i({},s.attrs,{id:t});delete l[c]}else if("id"in s.attrs)f.push("id");if(u in s.attrs){const t=s.attrs[u];l=i({},s.attrs,{for:t});delete l[u]}else if("htmlFor"in s.attrs)f.push("htmlFor");for(var o=0,a=f;o<a.length;o++){const n=a[o];const c=s.attrs[n];l=i({},s.attrs);if(c in r.ids)l[n]=r.ids[c];else{let s;if(t.isDevelopment){let t=++r.id;s=`${t}`;while(s.length<e)s=`0${s}`}else s=L.id(e);const o=`${c}_${s}`;r.ids[c]=o;l[n]=o}}return t.h(s.tag,l,s.children.map(T(e,n,r)))}else return s};const z=(t=4,n="real")=>e.compose(N(t=>U in t?{[U]:t[U]}:{}),O(({state:t})=>{if(!(U in t)){const e={ids:{},id:0};t[U]=e;return{[U]:e}}else return{}}),p(e=>r=>T(t,n,r.state[U])(e())));const G=(t,e)=>{let n=t;var r=true;var s=false;var o=undefined;try{for(var i=e[Symbol.iterator](),a;!(r=(a=i.next()).done);r=true){const t=a.value;if(n==null)break;n=n.childNodes[t]||null}}catch(t){s=true;o=t}finally{try{if(!r&&i.return!=null){i.return()}}finally{if(s){throw o}}}return n};const H=Symbol.for("__malina_refs");const B=t=>t.join(".");const K=new Set;const W=1e4;const J=e=>t.warn(`Incorrect use of refs:\n\n${e}\n\nViews can only handle its own refs. When a ref passed to a child-node inside another view-node it will be ignored`);const Q=(e,n,r=null)=>{const s=t.isElementNode(n);const o=t.isViewNode(n);if(s&&e in n.attrs){if(r!=null&&K.size<W)K.add(r.tag.id);J(r||n);return true}else if(s||o&&!K.has(n.tag.id)){let t=false;var i=true;var a=false;var l=undefined;try{for(var c=n.children[Symbol.iterator](),u;!(i=(u=c.next()).done);i=true){const s=u.value;t=Q(e,s,o?n:r);if(t)break}}catch(t){a=true;l=t}finally{try{if(!i&&c.return!=null){c.return()}}finally{if(a){throw l}}}return t}else return false};const X=(t,e,n,r)=>e.children.map((e,s)=>{const o=n.concat([s]);return Y(t,e,o,r).node});const Y=(n,r,s,o)=>{const i=t.isElementNode(r);if(i&&n in r.attrs){const i=r.attrs[n];if(!(i instanceof Function)&&typeof i!=="string")throw new Error("Ref consumer must be a function or a string");o.set(B(s),{path:s,consumer:i});const a=X(n,r,s,o);const l=t.h(r.tag,e.omit([n],r.attrs),a);return{refs:o,node:l}}else if(i){const e=X(n,r,s,o);const i=t.h(r.tag,r.attrs,e);return{refs:o,node:i}}else if(t.isDevelopment&&t.isViewNode(r)&&!K.has(r.tag.id))Q(n,r,r);return{refs:o,node:r}};const Z=(t,e)=>{const n=new Map;if(Array.isArray(e)){const r=[];for(const s in e){const o=[s];r.push(Y(t,e,o,n).node)}return{refs:n,node:r}}else return Y(t,e,[],n)};const tt=(t,{path:e,consumer:n})=>{const r=G(t.element,e);if(r==null)throw new Error("Internal error: element not found by ref");if(n instanceof Function)n(r);else t.state[n]=r};const et=(t,e,n)=>{var r=true;var s=false;var o=undefined;try{for(var i=n.keys()[Symbol.iterator](),a;!(r=(a=i.next()).done);r=true){const r=a.value;if(e==null||!e.has(r))tt(t,n.get(r));else{const s=e.get(r);const o=n.get(r);if(s.consumer!==o.consumer)tt(t,o)}}}catch(t){s=true;o=t}finally{try{if(!r&&i.return!=null){i.return()}}finally{if(s){throw o}}}};const nt=(t,e)=>{var n=true;var r=false;var s=undefined;try{for(var o=e.values()[Symbol.iterator](),i;!(n=(i=o.next()).done);n=true){const e=i.value.consumer;if(e instanceof Function)e(null);else t.state[e]=null}}catch(t){r=true;s=t}finally{try{if(!n&&o.return!=null){o.return()}}finally{if(r){throw s}}}};const rt=(t="ref")=>e.compose(p(e=>n=>{const r=e();const s=Z(t,r),o=s.refs,i=s.node;n.state[H].next=o;return i}),d({create:t=>{t.state[H]={prev:null,next:null}},mount:t=>{et(t,t.state[H].prev,t.state[H].next);t.state[H].prev=t.state[H].next},update:t=>{et(t,t.state[H].prev,t.state[H].next);t.state[H].prev=t.state[H].next},unmount:t=>{nt(t,t.state[H].next);t.state[H].prev=null}}));const st={};st.finishUpdate=(t=>({state:n})=>{const r=i({},n.store,{},t);if(!e.shallowEqual(n.store,r))return{store:r}});st.update=(t=>(function(){var e=r(function*({state:e,actions:n}){let r=i({},e.store);let s=t;if(t instanceof Function)s=t(r);if(s instanceof Promise)s=yield s;if(s!=null)yield n.finishUpdate(s)});return function(t){return e.apply(this,arguments)}})());const ot=t=>(function(){var e=r(function*(...e){const n=yield t(...e);return n.store});return function(){return e.apply(this,arguments)}})();const it=Symbol.for("__malina_store");const at=e.compose(O(({state:t,actions:e})=>({[it]:{state:t.store,update:ot(e.update)}})));const lt=t.view(h(({state:e,children:n})=>t.h(e.view,e.passed,n)),u({store:null}),f(st),at);const ct=e=>t.decorator(n=>({state:r,children:s})=>t.h(lt,{store:e,passed:r,view:n},s));const ut=(...t)=>({});const ft=(t=ut,e=ut)=>N(n=>{if(it in n){const r=n[it];const s=t!=null?t:ut;const o=e!=null?e:ut;return i({},s(r.state),{},o(r.update))}else return{}});const dt=t=>n=>{const r={};var s=true;var o=false;var i=undefined;try{for(var a=e.keys(t)[Symbol.iterator](),l;!(s=(l=a.next()).done);s=true){const e=l.value;const s=t[e];if(s instanceof Function)r[e]=((...t)=>n(s(...t)));else r[e]=dt(s)(n)}}catch(t){o=true;i=t}finally{try{if(!s&&a.return!=null){a.return()}}finally{if(o){throw i}}}return r};const ht=t=>t.split("-").length>=2;const pt=t=>{if(!ht(t))throw new Error(`"${t}" is not valid custom element name`)};const mt=(e,n,r,{shadow:s="open",observe:o=[]})=>(class extends e.HTMLElement{constructor(...t){const n=super(...t);this.view=null;this.childObserver=new e.MutationObserver(this.handleChildMutations.bind(this));this.expectedRemove=[];this.waitingChildren=true;return n}static get observedAttributes(){return o||[]}connectedCallback(){if(this.view==null){const c=this.attachShadow({mode:s});const u={};var r=true;var o=false;var i=undefined;try{for(var a=this.attributes[Symbol.iterator](),l;!(r=(l=a.next()).done);r=true){const t=l.value;u[t.name]=t.value}}catch(t){o=true;i=t}finally{try{if(!r&&a.return!=null){a.return()}}finally{if(o){throw i}}}const f=Array.from(this.childNodes);this.view=t.instantiate(e.document,t.h(n,u,f));const d=this.view.render();c.appendChild(d.content)}this.view.attach(this.shadowRoot);this.childObserver.observe(this,{childList:true})}disconnectedCallback(){this.childObserver.disconnect();this.view.unmount()}attributeChangedCallback(t,e,n){if(this.view!=null){this.view.update({[t]:n})}}destroy(){this.view.destroy()}handleChildMutations(t){var e=true;var n=false;var r=undefined;try{for(var s=t[Symbol.iterator](),o;!(e=(o=s.next()).done);e=true){const t=o.value;if(t.type==="childList"){this.updateChildren(t);break}}}catch(t){n=true;r=t}finally{try{if(!e&&s.return!=null){s.return()}}finally{if(n){throw r}}}}updateChildren(t){if(this.waitingChildren){this.waitingChildren=false;const t=Array.from(this.childNodes);this.expectedRemove=t;this.view.update(null,t)}else{const e=this.expectedRemove.length;if(e!==t.removedNodes.length){this.waitingChildren=true;this.updateChildren(t);return}for(let n=0;n<e;n++){const e=this.expectedRemove[n];const r=t.removedNodes[n];if(e!==r){this.waitingChildren=true;this.updateChildren(t);return}}this.waitingChildren=true;this.expectedRemove=null}}});const vt=p(t=>n=>{const r=t();if(r.tag!=="template")throw new Error("Root element of a web-component must be a 'template' element");if(e.keys(r.attrs).length>0)throw new Error("Root element of a web-component must not have any attributes");return r});const yt=(e,n,r={})=>{pt(n);return t.decorator(t=>{if("customElements"in e){const s=mt(e,vt(t),n,r);e.customElements.define(n,s);return s}return null})};const wt=()=>{const e=t.getGlobal();if(!("window"in e))throw new Error('"window" not found in global scope');return e.window};const bt=(...t)=>{if(t.length===1){const e=wt();return yt(e,t[0])}else if(t.length===2){if(typeof t[0]==="string"){const e=wt();return yt(e,t[0],t[1])}else return yt(t[0],t[1])}else return yt(t[0],t[1],t[2])};exports.compose=e.compose;exports.withBehavior=c;exports.withState=u;exports.withActions=f;exports.withLifecycle=d;exports.withTemplate=h;exports.mapTemplate=p;exports.mapState=m;exports.renameState=v;exports.withContext=O;exports.getContext=N;exports.cssModules=q;exports.withUniqIds=z;exports.withRefs=rt;exports.withStore=ct;exports.connect=ft;exports.bindActions=dt;exports.webComponent=bt;
